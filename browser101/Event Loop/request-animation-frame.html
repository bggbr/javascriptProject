<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    button {
        background-color: blanchedalmond;
    }
</style>

<body>
    <button>RequestAnimationFrame</button>
</body>
<script>
    const button = document.querySelector('button');
    button.addEventListener('click', () => {
        requestAnimationFrame(() => {
            document.body.style.backgroundColor = 'beige';
        });
        requestAnimationFrame(() => {
            document.body.style.backgroundColor = 'orange';
        });
        requestAnimationFrame(() => {
            document.body.style.color = 'red';
        });
        setTimeout(() => {
            // 지금 수행되고 있는 즉, 콜 스택 안에서 이 코드 블럭이 실행되는 이 순간 말고, 이게 끝나면 이벤트 루프가 한 바퀴 돌 때 그 다음에 이 코드 블럭을 실행해 달라고 말하고 싶을 때 그때 많이 쓴다. 
            // 다음 이벤트 루프가 동작할 때 내 것을 실행해 달라고 하기 위한 테크닉이다.
            // 모든 코드가 수행된 다음 턴 때 수행이 되도록!
        }, 0)
    })
    // 정리
    // 자바스크립트 엔진에는 힙과 콜 스택이 있다.
    // 콜 스택은 함수가 실행되는 과정을 기억하기 위해 쓰이는 자료구조이다.
    // 그리고 자바 스크립트가 동작하는 런타임 환경에서는 이렇게 태스크 큐와 마이크로 태스크 큐를 이용해서
    // 비동기적인 처리를 하게 되는데 태스크 큐는 한 번에 하나 씩만! 마이크로 태스크 큐는 들어 있는 모든 아이들을 수행할 때까지 가지고 오게 되고 이 렌더는 이벤트 루프가 주기적으로! 매번은 아니지만!
    // 브라우저에게 UI를 업데이트 하기 위해서 자주 자주 들러준다. 
    // 우리가 호출한 리퀘스트 애니메이션 프레임 콜백 큐는 이 업데이트가 일어나기 전에,
    // 한 번 쭈욱 순회하면서 코드가 실행된다.
</script>

</html>