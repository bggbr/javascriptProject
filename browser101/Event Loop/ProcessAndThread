프로세스란?
- 운영체제 위에서 연속적으로 실행되고 있는 프로그램이다. 음악 재생이나 사진 뷰어 등 각각의 프로세스를 가지고 있다. 서로 독립적으로 실행되고 있다. 
하나의 프로세스가 문제가 생기면 해당 어플리케이션만 죽어버리는 것과 같다.
프로세스는 운영체제 위에서 독립적으로 메모리 위에서 실행되고 있는 것이다.
각 프로세스마다 자원이 실행된다. 자원이란 메모리와 데이터들이 지정되어 있다.
프로세스 안에는 프로그램을 실행하기 위한 코드가 들어있다. 
그 코드와 그 프로세스 안에서 함수가 어떤 순서로 실행되어야 하는지 함수가 끝나면 어디로 돌아가야 하는지에 대한
스택 정보!
Heap은 오브젝트를 생성하거나 데이터를 만들 때 그 데이터들이 저장되는 공간이다.
Heap에는 동적으로 할당된 변수들이 저장되는 반면에 데이터에는 전역 변수나 스태틱 변수들이 할당이 되어진다.
각각의 프로세스는 자기들에게 필요한 코드, 동작하고 있는 순서를 기억하는 스택, 데이터들이 들어가 있는 힙과 데이터들이 들어가 있다.

쓰레드는 무엇일까?
- 쓰레드는 한 프로세스 안에서 여러 개가 동작할 수 있다.
각각 저마다 해야 되는 업무를 배정 받는다. - 일꾼이라고도 불린다.
자기들만의 수행해야 되는 함수의 호출을 기억해야 되기 때문에 쓰레드마다 스택이 할당되어져 있다.
하지만 이 프로세스 안에서 동작하는 일꾼(쓰레드)는 결국은 한 프로그램을 위해서 일해야 되므로
프로세스에 지정된 코드와 데이터, 힙들을 공통적으로 접근해서 공통적으로 업데이트가 가능하다.
즉, 내 프로그램에서 음악을 들으면서 사진을 편집할 수 있는 어플리케이션이 있다면 
각각 쓰레드 음악을 재생하는 쓰레드 하나와 사진을 편집할 수 있는 쓰레드 그리고 다른 쓰레드에서는 음악의 데이터를
서버에서부터 받아와서 처리하는 이런 일들을 각각 저마다 할 수 있다.
그리고 이 쓰레드들은 동시다발적으로 발생할 수 있기 때문에 이 프로세스가 조금 더 효율적으로 일을 할 수 있도록 도움을 준다. 만약 프로세스가 하나의 일 밖에 하지 못한다면 음악을 듣는 동안 사진 편집을 할 수 없을 것이다.
이렇게 쓰레드들이 여러 개가 존재하기 때문에 다양한 일들을 동시에 할 수 있다.

여기서 포인트는 쓰레드는 자기가 일을 수행할 때, 자기가 어디서부터 어디까지 일을 했고, 다음엔 어디로 가야 하는지
이런 일에 흐름을 기억할 수 있는 고유의 스택이 지정되어져 있지만, 데이터나 코드나, 힙 같은 공통적인 데이터 리소느느 프로세스에 있기 때문에 쓰레드들은 이 프로세스에 공통적으로 할당된 리소스에 동시 다발적으로 접속해서 동시다발적으로 업데이트 해야 되서 이렇게 서로 공유하게 사용된다.

멀티쓰레딩이 중요한 이유는 공통적으로 일을 하면서 순서가 맞지 않거나 하면 발생할 수 있는 문제가 있다.
멀티쓰레딩 프로그래밍이 조금 까다롭다.

결론은 프로세느는 프로그래밍을 동작하는 최고의 단위이고, 쓰레드는 프로그램안에서 여러 일을 수행할 수 있는 작은 일꾼 단위이다. 

JAVA는 멀티쓰레딩이 가능한 언어이다. 그 말은 우리가 프로그래밍을 짤 때, 사용자가 이 데이터를 보고 있는 동안 
서버에서 데이터를 받아 오는 것은 쓰레드 A에서 해야지 그리고 이 일은 쓰레드 B에서 해야지. 각각 지정해서 프로그래밍을 짤 수 있다. 굉장히 다양한 것을 할 수 있다.
자바로 멀티쓰레딩을 구현하려면 배워야할 것이 많다.

자바스크립트는 멀티 쓰레딩이 아닌 싱글 쓰레드이다. 하지만 제가 사용하고 있는 어플리케이션에서는 이거 하는 동안 다른 작업도 가능했었는데???
브라우저라는 프로그램 안에는 여러 가지의 쓰레드가 들어 있다.
그래서 우리가 브라우저 즉, 웹 APIs를 이용하게 되면 멀티 쓰레드가 가능하다.
즉, 자바스크립트가 동작하는 실행 환경에서는 다양한 방식을 이용해서 조금 멀티쓰레딩 같은 효과를 얻을 수 있다.
그리고 자바스크립트가 실행되는 이 런타임 환경(실행 환경)에서는 이런 멀티 쓰레딩 뿐만 아니라 이벤트 루프를 이용해서 조금 더 다양한 동작을 실행할 수 있다.

자 우리의 웹 어플리케이션이 브라우저 위에 올라가는 순간 자바스크립트 엔진이 우리가 자바스크립트로 작성한 소스를 한줄한줄 분석하고 실행하게 된다. 이것이 정확하게 어떻게 되는지 궁금!

자바스크립트 엔진에는 크게 메모리 힙과 콜 스택으로 나눠져 있다.
메모리 힙은 변수를 선언해서 오브젝트를 할당하거나 문자열이나 숫자를 할당하게 되면 그 데이터들은 전부 메모리 힙에 저장이 된다. 메모리 힙은 구조적으로 정리된 자료구조가 아니라 아무 곳에 저장이 된다.

콜 스택이란 우리가 함수를 실행하는 순서에 따라 차곡차곡 쌓아가는 함수이다.
second()
fisrt()
main()
과 같은 순서로 스택이 쌓이게 된다.
콜 스택에는 어디로 돌아와야 하는지 정보도 들어가 있다.
콜 스택은 함수들이 호출하는 순서를 기억했다가 함수가 끝나면 원래 있던 자리로 돌아가기 위해서 사용되는 자료구조 중 하나이다.
모든 프로세스와 쓰레드 안에는 각각 저마다의 콜 스택이 존재한다.
왜냐하면 일을 수행할 때 어디서 왔고 어디로 다시 돌아가야 하는지 정보를 기억해야 되기 때문이다.

우리가 자바스크립트 런타임 환경에서는 자바스크립트만으로는 할 수 있는 것이 너무 한정적이었다.
하지만 Wep APIs라는 멋진 친구가 있다. 다양한 것을 할 수 있다. 브라우저에서 제공하는 APIs이기 때문에 브라우저의 멀티 쓰레딩을 이용하여 조금 더 다양한 일을 동시에 할 수 있다. 

그 중에 대표적으로 fetch()를 이용해서 백엔드에서 데이터를 받아온다던지 setTimeout을 이용해서 콜백함수를 실행하는 등 멋진 일들을 할 수 있다.

Web APIs를 이용하여 우리가 등록한 콜백 함수는 어떻게 동작이 되냐?
어떻게 Web APIs와 자바스크립트 엔진이 서로 일을 하게 되는 건가?

setTimeout이라는 함수는 콜 스택에 들어가고 Web APIs로 전달이 된다.
자바스크립트 엔진과 Web APIs가 병렬적으로 일을 한다.
Web APIs에서 지정된 시간이 끝나면 그 콜백을 Task Queue에 전달한다.
Web APIs는 우리가 등록한 콜백 함수를 원하는 때에 지정된 시간에 알아서 Task Queue에 넣어주는구나
Task Queue에 들어 있는 저 콜백은 언제 실행이 되나요?
이렇게 Task Queue와 콜 스택을 관찰하는 아이가 하나 있다. 바로 이벤트 루프이다.
계속 while과 같은 빙글빙글 돌고 있는 아이이다.

콜 스택에 존재하는 main() 함수까지 pop()이 되면, 이벤트 루프에 있는 아이를 콜 스택으로 데리고 온다.
그러면 자바스크립트 엔진이 콜 스택에 들어온 타임아웃 콜백이라는 것을 실행하게 된다.

이벤트 루프는 프로세스가 동작하는 동안 루프를 돌면서 콜 스택이 비어져 있다면 태스크 큐에 들어 있는 아이를 콜 스택으로 가져와서 자바스크립트 엔진이 수행할 수 있도록 도와준다.

자바스크립트 코드의 버튼에 클릭 이벤트 리스너를 등록해 놓으면, 브라우저에서 버튼이 클릭이 되면, Web APIs는 이벤트 루프에 콜백 함수를 큐 안에다가 넣는다. 한 번 더 누르면 우리가 등록한 콜백 함수를 태스트 큐에 들어가게 된다. 그리고 지금 이벤트 루프는 콜 스택에 타임 아웃 콜백이 수행되고 있기 때문에 즉, 콜 스택이 비어 있지 않기 때문에 기다렸다가 타임 아웃 콜백이 수행이 되면 이벤트 루프에 있는 클릭의 콜백을 하나를 콜 스택에 가지고 온다.

이 태스트 큐에 있는 아이는 한 번에 하나만 이렇게 콜 스택으로 가져오게 된다. 그래서 가져온 클릭 콜백이 다 실행될 때까지 다시 기다렸다가 클릭 콜백이 끝나면 태스크 큐에 있는 클릭을 다시 가져오게 되고 수행을 하게 된다.

======================================================
정리

자바스크립트 엔진에는 메모리 힙과 콜 스택이 있다. 그리고 자바스크립트 런타임 환경에서는 태스크 큐라는 것이 있는데, 바로 Web APIs에서 우리가 등록한 콜백을 특정한 이벤트가 발생하게 되면 태스크 큐에 넣어서 이 이벤트 루프라는 아이가 계속 계속 감시하면서 콜 스택이 비어져 있을 때, 태스크 큐에 있는 아이를 하나씩 콜 스택으로 가져온다.

!! 중요한 개념 !! - 콜 스택에서 수행 중인 아이는 끝날 때까지 보장이 된다. 즉, 다른 태스크나 다른 일들을 할 수 없다. 코드 블럭이 끝날 때 까지 이벤트 루프가 기다렸다가 다음에 다른 밑에 있는 콜 스택이 수행이 되거나 태스크 큐에 있는 아이가 실행이 되어진다.

이제는 Micro Task Queue와 Render Sequence에 대해서 알아보자.

Micro Task Queue는 우리가 흔히 쓰는 Promise에 쓰이는 콜백, then에 등록한 콜백 함수, Mutation observer에 등록한 콜백이 등록된다.

Render는 화면에 업데이트 해주는 것이다. Request Animation Frame라는 APIs가 존재한다. 이 APIs를 통해 콜백을 등록해 놓으면, 다음에 브라우저가 업데이트 되기 전에 내 콜백을 실행해줘라는 APIs가 있다. 이제 그때 우리가 호출하는 콜백은 Request Animation Frame라는 Queue에 차곡차곡 쌓여진다. 그래서 이 렌더 순서가 있다. 

그런데 어떻게 브라우저는 이 순서대로 잘 실행할까?
=> 이벤트 루프는 while 문과 같이 빙글 빙글 도는 루프 중 하나이다. 그래서 이름이 이벤트 루프이다.
이 이벤트 루프는 콜 스택에 수행 중인 함수가 있다면 이 콜 스택이 끝날 때 까지 계속 머물러 있다. 꼼짝도 하지 않고!! 기다리고 있다.

콜 스택에 등록한 함수에서 굉장히 시간이 오래 걸리는 것을 하게 되면, 사용자에게 더 이상 화면이 업데이트 되지 않는다. 다른 클릭이 발생해도 클릭에 등록된 콜백 함수가 실행이 되지 않는다.

이 렌더 쪽으로 갈 수도 있고 안 갈 수도 있다. 그 말이 무슨 말이냐면, 
// 사람 눈에 자연스럽게 보이려면 60fps이 되야 한다. 이렇게 하기 위해서는 16.7ms 동안 업데이트가 돼야 한다.
이벤트 루프는 1ms 걸린다 한 바퀴 도는데!
16.7ms 안에 렌더 트리를 업데이트 해준다.

그 다음 Micro Task Queue에 도착하여 이 Micro Task Queue 안에 콜백이 없어질 때 까지 계속 머무른다.
여기에 머물러 있는 동안 새로운 콜백이 들어와도 새로 들어온 콜백이 없어질 떄 까지 머무른다.

그 다음 Task Queue에 도착한다. Task Queue는 하나만 콜 스택에 등록을 한다.

그리고 다시 이벤트 루프를 돈다.