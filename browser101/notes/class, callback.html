<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // 클래스 다이어그램 - 클래스를 한 눈에 보기 쉽게 만든 것.
    // 연습할 것!!
    class Counter {
        // constructor도 함수이다.
        constructor(runEveryFiveTimes) {
            this.counter = 0;
            this.callback = runEveryFiveTimes;
        }
        // 클래스 내에서 함수 선언 시, 함수 이름을 선언하지 않아도 된다.
        increase(runIfFiveTime) {
            this.counter++;
            console.log(this.counter);
            if (this.counter % 5 === 0) {
                this.callback(this.counter);
                // this.callback && this.callback(this.counter);
            }
        }
    }
    // 클래스에 우리가 원하는 기능을 다 정의하게 되면, 사용하는 사람이 자세하게 컨트롤할 수 없고 재사용이 떨어진다. 하지만 위와 같은 callback 함수를 이용해서 함수를 만들게 되면 counter를 쓰는 사람이 자신의 입맛에 맞게 만들 수 있다.
    // const coolCounter = new Counter(printSomething);
    const coolCounter =
        new Counter(); // -> 오류가 발생한다. this.callback && this.callback(this.counter); 추가한다. 콜백이 있을 때 this.counter를 출력하도록!!

    function printSomething(num) {
        console.log(`WoW ${num}`);
    }

    function alertNum(num) {
        alert(`alert! ${num}`);
    }
    coolCounter.increase(printSomething);
    coolCounter.increase(printSomething);
    coolCounter.increase(printSomething);
    coolCounter.increase(printSomething);
    coolCounter.increase(printSomething);

    // 여기서 문제점은? increase함수를 호출할 때마다 printSomething을 전달해야 한다.
    // constructor에 콜백 함수를 전달한다.
    coolCounter.increase();
    coolCounter.increase();
    coolCounter.increase();
    coolCounter.increase();
    coolCounter.increase();

    // 하나의 클래스로 다양한 오브젝트를 만들어서 서로 다른 기능을 수행하는 오브젝트를 만들 수 있다.
    // 이렇게 하면 클래스의 재사용 가능성이 높아진다.
    // 가능하면, 클래스를 완전체로 만들기 보다는 레고로 원하는 기능을 조립해서 만드는 것 처럼, 재조립이 가능하도록 만드는 것이 좋다.
    const printCounter = new Counter(printSomething);
    const alertCounter = new Counter(alertNum);
</script>

</html>